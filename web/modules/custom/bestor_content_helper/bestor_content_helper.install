<?php

use Symfony\Component\Yaml\Yaml;
use Drupal\node\Entity\Node;
use Drupal\Component\Utility\Html;
use Drupal\Core\Url;
use Drupal\Core\Entity\FieldableEntityInterface;

function bestor_content_helper_install() {
  _bestor_site_settings_sync();
}

function bestor_content_helper_uninstall() {
  $storage = \Drupal::entityTypeManager()->getStorage('bestor_site_setting');
  $entities = $storage->loadMultiple();
  if ($entities) {
    $storage->delete($entities);
  }
}


/**
 * Rebuild bestor_site_setting table and resync from YAML.
 */
function bestor_content_helper_update_9001() {
  $database = \Drupal::database();
  
  // Drop the table if it exists
  if ($database->schema()->tableExists('bestor_site_setting')) {
    $database->schema()->dropTable('bestor_site_setting');
  }
  
  // Uninstall and reinstall entity type to recreate table
  $update_manager = \Drupal::entityDefinitionUpdateManager();
  $entity_type = \Drupal::entityTypeManager()->getDefinition('bestor_site_setting');
  
  // Force reinstall
  $update_manager->installEntityType($entity_type);
  
  // Resync settings from YAML
  _bestor_site_settings_sync();
  
  return t('Rebuilt bestor_site_setting table and resynced from YAML.');
}


function _bestor_site_settings_sync() {
  $path = \Drupal::service('extension.list.module')
    ->getPath('bestor_content_helper') . '/bestor_content_helper.site_settings.yml';

  if (!file_exists($path)) {
    return;
  }

  $settings = Yaml::parse(file_get_contents($path));
  if (empty($settings)) {
    return;
  }

  $storage = \Drupal::entityTypeManager()->getStorage('bestor_site_setting');

  foreach ($settings as $id => $definition) {
    try {
      $entity = $storage->load($id);
      if (!$entity) {
        $storage->create([
          'id' => $id,
          'label' => $definition['label'] ?? $id,
          'description' => $definition['description'] ?? '',
          'value' => $definition['default_value'] ?? '',
          'value_nl' => $definition['default_value_nl'] ?? '',
          'value_fr' => $definition['default_value_fr'] ?? '',
          'setting_group' => $definition['setting_group'] ?? ''
        ])->save();
      }
    }
    catch (\Exception $e) {
      \Drupal::logger('bestor_content_helper')->error('Error: @msg', ['@msg' => $e->getMessage()]);
    }
  }
}


function bestor_content_helper_update_9004() {
  $nids = \Drupal::entityQuery('node')
    ->accessCheck(FALSE)
    ->execute();

  $entity_type_manager = \Drupal::entityTypeManager();
  $storage = $entity_type_manager->getStorage('node');
  $nodes = $storage->loadMultiple($nids);

  foreach ($nids as $nid) {
    $node = $nodes[$nid] ?? NULL;
    if (!$node) {
      continue;
    }

    $fields = [];
    foreach (['body', 'field_formatted_text', 'field_table', 'field_references'] as $field) {
      if ($node->hasField($field) && !$node->get($field)->isEmpty()) {
        $field_value = $node->get($field)->getValue();
        if (!empty($field_value[0]['value'])) {
          $fields[$field] = $field_value[0]['value'];
        }
      }
    }

    if ($fields) {
      _convertHyperlinks($node, $fields);
      $node->save();
    }
  }
}


/**
 * Helper function: convert hyperlinks to entity links.
 */
function _convertHyperlinks(FieldableEntityInterface &$entity, $fields_to_update) {
  $entity_type_manager = \Drupal::entityTypeManager();
  $path_alias_manager = \Drupal::service('path_alias.manager');
  $logger = \Drupal::logger('bestor_link_convert');
  
  // Allowed hostnames
  $allowed_hosts = ['bestor.be', 'bestor.ugent.be', 'localhost', '127.0.0.1'];
  
  $logger->info("=== Converting links in entity @type/@id ===", [
    '@type' => $entity->getEntityTypeId(),
    '@id' => $entity->id(),
  ]);

  foreach ($fields_to_update as $field_name => $content) {
    $logger->info("Processing field: @field", ['@field' => $field_name]);
    
    $doc = Html::load($content);
    $changed = FALSE;
    $links_found = 0;
    $links_converted = 0;
    $links_skipped = 0;

    foreach ($doc->getElementsByTagName('a') as $element) {
      $links_found++;
      $href = $element->getAttribute('href');
      
      $logger->info("  Link #@num: @href", [
        '@num' => $links_found,
        '@href' => $href ?: '(empty)',
      ]);
      
      // Skip if already has Linkit attributes
      if (!empty($element->getAttribute('data-entity-uuid'))) {
        $logger->info("    → SKIP: Already has data-entity-uuid");
        $links_skipped++;
        continue;
      }

      if (empty($href)) {
        $logger->info("    → SKIP: Empty href");
        $links_skipped++;
        continue;
      }
      
      $parsed = parse_url($href);
      
      // Check if internal link
      if (!empty($parsed['host'])) {
        $is_internal = FALSE;
        foreach ($allowed_hosts as $allowed) {
          if (str_contains(strtolower($parsed['host']), $allowed)) {
            $is_internal = TRUE;
            $logger->info("    ✓ Host matches: @host", ['@host' => $parsed['host']]);
            break;
          }
        }
        if (!$is_internal) {
          $logger->info("    → SKIP: External host: @host", ['@host' => $parsed['host']]);
          $links_skipped++;
          continue;
        }
      } else {
        $logger->info("    ✓ No host (relative link)");
      }

      // Skip mailto links
      if (!empty($parsed['scheme']) && $parsed['scheme'] == 'mailto') {
        $logger->info("    → SKIP: Mailto link");
        $links_skipped++;
        continue;
      }

      // Skip empty, homepage, or anchors
      if (empty($parsed['path']) || $parsed['path'] === '/' || str_starts_with($parsed['path'], '#')) {
        $logger->info("    → SKIP: Empty/homepage/anchor");
        $links_skipped++;
        continue;
      }

      $path = $parsed['path'];
      if (!str_starts_with($path, '/')) {
        $path = '/' . $path;
        $logger->info("    ✓ Added leading slash: @path", ['@path' => $path]);
      }

      // FIX BROKEN PATHS: /123 → /node/123
      if (preg_match('#^/([a-z]{2}/)?(\d+)$#', $path, $matches)) {
        $language_prefix = $matches[1] ?? '';
        $entity_id = $matches[2];
        
        $logger->info("    ✓ Detected numeric path: @id", ['@id' => $entity_id]);
        
        // Try to load as node first
        $test_entity = $entity_type_manager->getStorage('node')->load($entity_id);
        if ($test_entity) {
          $old_path = $path;
          $path = '/' . $language_prefix . 'node/' . $entity_id;
          $logger->info("    ✓ Fixed path: @old → @new", [
            '@old' => $old_path,
            '@new' => $path,
          ]);
        }
        else {
          $logger->warning("    → SKIP: Node @id not found", ['@id' => $entity_id]);
          $links_skipped++;
          continue;
        }
      }
      
      try {
        // Convert alias to system path if needed
        $system_path = $path_alias_manager->getPathByAlias($path);
        $logger->info("    ✓ System path: @path", ['@path' => $system_path]);
        
        $url = Url::fromUri("internal:" . $system_path);
      }
      catch (\InvalidArgumentException $e) {
        $logger->warning("    → SKIP: Invalid URL: @msg", ['@msg' => $e->getMessage()]);
        $links_skipped++;
        continue;
      }

      if (!($url->isRouted() && str_starts_with($url->getRouteName(), 'entity.'))) {
        $logger->info("    → SKIP: Not an entity route: @route", [
          '@route' => $url->isRouted() ? $url->getRouteName() : 'not routed',
        ]);
        $links_skipped++;
        continue;
      }

      $route = $url->getRouteParameters();
      $entity_type = key($route);
      $entity_id = $route[$entity_type];
      
      $logger->info("    ✓ Entity route: @type/@id", [
        '@type' => $entity_type,
        '@id' => $entity_id,
      ]);
      
      if (!in_array($entity_type, ['node'])) {
        $logger->info("    → SKIP: Entity type not supported: @type", ['@type' => $entity_type]);
        $links_skipped++;
        continue;
      }

      try {
        $linked_entity = $entity_type_manager->getStorage($entity_type)->load($entity_id);
        
        if ($linked_entity) {
          // Add Linkit data attributes
          $element->setAttribute('data-entity-type', $entity_type);
          $element->setAttribute('data-entity-substitution', 'canonical');
          $element->setAttribute('data-entity-uuid', $linked_entity->uuid());
          $element->setAttribute('href', $system_path);
          
          $logger->info("    ✓✓✓ CONVERTED: @old → @new (UUID: @uuid)", [
            '@old' => $href,
            '@new' => $system_path,
            '@uuid' => substr($linked_entity->uuid(), 0, 8) . '...',
          ]);
          
          $changed = TRUE;
          $links_converted++;
        } else {
          $logger->warning("    → SKIP: Could not load @type/@id", [
            '@type' => $entity_type,
            '@id' => $entity_id,
          ]);
          $links_skipped++;
        }
      }
      catch (\Exception $e) {
        $logger->error("    → ERROR: @msg", ['@msg' => $e->getMessage()]);
        $links_skipped++;
      }
    }

    if ($changed) {
      $content = Html::serialize($doc);
      $entity->set($field_name, [
        'value' => $content,
        'format' => $entity->get($field_name)->format,
      ]);
      
      $logger->info("Field @field: @found links found, @converted converted, @skipped skipped", [
        '@field' => $field_name,
        '@found' => $links_found,
        '@converted' => $links_converted,
        '@skipped' => $links_skipped,
      ]);
    } else {
      $logger->info("Field @field: No changes needed (@found links, all skipped)", [
        '@field' => $field_name,
        '@found' => $links_found,
      ]);
    }
  }
}