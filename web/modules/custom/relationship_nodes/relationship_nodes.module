<?php

use Drupal\Core\Form\FormStateInterface;
use Drupal\relationship_nodes\Form\RelationExtendedEntityInlineForm;
use Drupal\field\Entity\FieldConfig;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\Core\Config\ConfigException;
use Drupal\relationship_nodes\RelationEntityType\AdminUserInterface\KeepLockedRelationFieldConfigListBuilder;
use Drupal\Core\Cache\RefinableCacheableDependencyInterface;
use Drupal\node\Entity\NodeType;
use Drupal\Core\Config\Entity\ConfigEntityInterface;
use Drupal\taxonomy\Entity\Vocabulary;
use Drupal\Core\Entity\EntityFormInterface;


function relationship_nodes_entity_bundle_field_info_alter(&$fields, $entity_type, $bundle) { 
  $type_id = $entity_type->id();
  if( $type_id === 'node'){
    $fieldAdder = \Drupal::service('relationship_nodes.virtual_field_adder');
    $fieldAdder->addFields($fields, $entity_type, $bundle);
  } elseif ($type_id === 'taxonomy_term') {
    $settingsManager = \Drupal::service('relationship_nodes.relation_bundle_settings_manager');
    $vocab_type = $settingsManager->getRelationVocabType($bundle);
    
    if($vocab_type == 'entity_reference'){
      $fieldnameResolver = \Drupal::service('relationship_nodes.field_name_resolver');
      $mirror_field_name = $fieldnameResolver->getMirrorFields('entity_reference');
      if(!empty($mirror_field_name)){
        $fields[$mirror_field_name]->addConstraint(available_mirror_term_constraint::class);
      }
    }
  }
  return $fields;
} 


function relationship_nodes_field_storage_config_update(FieldStorageConfig $storage) {
  $field_name = $storage->getName();
  $fieldResolver = \Drupal::service('relationship_nodes.field_name_resolver');
  $module_fields = $fieldResolver->getAllRelationFieldNames();
  if (!in_array($field_name, $module_fields)) {
    return;
  }
  $bundleValidator = \Drupal::service('relationship_nodes.relation_validation_service');
  if(!empty($bundleValidator->getFieldStorageValidationErrors($storage))){
    throw new ConfigException("The fieldstorage {$field_name} doesn't meet the required 'Relationship Nodes' configuration.");
  }
}


function relationship_nodes_field_config_update(FieldConfig $field) {
  $settingsManager = \Drupal::service('relationship_nodes.relation_bundle_settings_manager');
  if(!$settingsManager->isRelationEntity($field->getTargetBundle())){
    return;
  }

  $field_name = $field->getName();
  $fieldResolver = \Drupal::service('relationship_nodes.field_name_resolver');
  $module_fields = $fieldResolver->getAllRelationFieldNames();
  
  if (!in_array($field_name, $module_fields)) {
    return;
  }

  $bundleValidator = \Drupal::service('relationship_nodes.relation_validation_service');

  if(!empty($bundleValidator->getFieldConfigValidationErrors($field))){
    throw new ConfigException("The fieldconfig {$field_name} doesn't meet the required 'Relationship Nodes' configuration.");
  }
}


function relationship_nodes_entity_type_alter(array &$entity_types) {
  if (isset($entity_types['node'])) {
    //$entity_types['node']->addConstraint(valid_related_entities_constraint::class);
  }
  if (isset($entity_types['field_config'])) {
    $entity_types['field_config']->setListBuilderClass(KeepLockedRelationFieldConfigListBuilder::class);
  }
}


function relationship_nodes_entity_bundle_info_alter(&$bundles) {
  $relation_bundles = [];
  if (isset($bundles['node'])) {  
    $settingsManager = \Drupal::service('relationship_nodes.relation_bundle_settings_manager');
    foreach($bundles['node'] as $bundle_id => $bundle){ 
      if(!$settingsManager->isRelationNodeType($bundle_id, [], true)){
        $bundles['node'][$bundle_id]['relation_bundle'] = [];
        continue;
      } 
      $relation_bundles[] = $bundle_id; 
    }
  }
  if(!empty($relation_bundles)){
    $bundleInfoService = \Drupal::service('relationship_nodes.relation_bundle_info_service');
    foreach($relation_bundles as $relation_bundle_id){
      $bundles['node'][$relation_bundle_id]['relation_bundle'] = $bundleInfoService->getRelationBundleInfo($relation_bundle_id);
    }
  }
}


function relationship_nodes_entity_type_build(array &$entity_types) {
  if (isset($entity_types['node'])) {
    $entity_types['node']->setHandlerClass('inline_form', RelationExtendedEntityInlineForm::class);
  }
}


function relationship_nodes_form_alter(array &$form, FormStateInterface $form_state, $form_id) {
  $alter_form_service = null;
  switch($form_id){
    case 'node_type_edit_form':
      $alter_form_service = \Drupal::service('relationship_nodes.node_type_form_alter');
      break;
    case 'taxonomy_vocabulary_form': 
      $alter_form_service = \Drupal::service('relationship_nodes.vocab_form_alter');
      break;
    default:
      if ($form_state->getFormObject() instanceof EntityFormInterface) {
        $alter_form_service = \Drupal::service('relationship_nodes.parent_node_form_alter');    
      }
      break;
  }

  if ($alter_form_service) {
    $alter_form_service->alterForm($form, $form_state, $form_id);
  }
}


function relationship_nodes_local_tasks_alter(&$local_tasks) {
  $field_config_updater = \Drupal::service('relationship_nodes.field_config_ui_updater');
  $field_config_updater->overrideLocalTasksEdit($local_tasks);

}


function relationship_nodes_module_implements_alter(array &$implementations, $hook) {
  if ($hook === 'entity_type_alter') {
    $module = 'relationship_nodes';
    if (isset($implementations[$module])) {
      $weight = $implementations[$module];
      unset($implementations[$module]);
      $implementations[$module] = $weight;
    }
  }
}