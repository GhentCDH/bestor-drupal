<?php

use Drupal\Core\Form\FormStateInterface;
use Drupal\relationship_nodes\Form\RelationExtendedEntityInlineForm;
use Drupal\field\Entity\FieldConfig;
use Drupal\field\Entity\FieldStorageConfig;
use Drupal\Core\Config\ConfigException;
use Drupal\relationship_nodes\KeepLockedRelationFieldConfigListBuilder;
use Drupal\Core\Cache\RefinableCacheableDependencyInterface;
use Drupal\node\Entity\NodeType;
use Drupal\relationship_nodes\Service\RelationFieldConfigHelper;
use Drupal\Core\Config\Entity\ConfigEntityInterface;
use Drupal\taxonomy\Entity\Vocabulary;


function relationship_nodes_entity_bundle_field_info_alter(&$fields, $entity_type, $bundle) { 
  $type_id = $entity_type->id();
  if( $type_id === 'node'){
    \Drupal::service('relationship_nodes.relationship_field_auto_adder')->addFields($fields, $entity_type, $bundle);
  } elseif ($type_id === 'taxonomy_term') {
    $vocab_info = \Drupal::service('relationship_nodes.relationship_info_service')->getRelationVocabInfo($bundle, $fields);
    if(!empty($vocab_info)){
      if($vocab_info['mirror_field_type'] == 'entity_reference_selfreferencing' && isset($fields[$vocab_info['mirror_field_name']])){
        $fields[$vocab_info['mirror_field_name']]->addConstraint(available_mirror_term_constraint::class);
      }
    }
  }
  return $fields;
} 

function relationship_nodes_field_storage_config_update(FieldStorageConfig $storage) {
  $locked_fields = ['related_entity_1', 'related_entity_2'];
  if ($storage->getTargetEntityTypeId() === 'node' && in_array($storage->getName(), $locked_fields)) {
    if ($storage->getType() !== 'entity_reference' ||
        $storage->getCardinality() !== 1 ||
        $storage->getSetting('target_type') !== 'node') {
      throw new ConfigException("The field {$storage->getName()} must remain a single-value entity_reference to nodes.");
    }
  }
}


function relationship_nodes_field_config_update(FieldConfig $field) {
  $locked_fields = ['related_entity_1', 'related_entity_2'];
  if (in_array($field->getName(), $locked_fields)) {
    $target_bundles = $field->getSetting('handler_settings')['target_bundles'] ?? [];
    if (count($target_bundles) > 1) {
      throw new ConfigException("The field {$field->getName()} must reference exactly one node type.");
    }
  }
}


function relationship_nodes_entity_type_alter(array &$entity_types) {
  if (isset($entity_types['node'])) {
    //$entity_types['node']->addConstraint(valid_related_entities_constraint::class);
  }
  if (isset($entity_types['field_config'])) {
    $entity_types['field_config']->setListBuilderClass(KeepLockedRelationFieldConfigListBuilder::class);
  }
}


function relationship_nodes_entity_bundle_info_alter(&$bundles) {
  $relation_bundles = [];
  if (isset($bundles['node'])) {  
    $relation_entity_validator = \Drupal::service('relationship_nodes.relation_entity_validator');
    foreach($bundles['node'] as $bundle_id => $bundle){ 
      if(!$relation_entity_validator->isValidRelationBundle($bundle_id, [], true)){
        $bundles['node'][$bundle_id]['relation_bundle'] = [];
        continue;
      } 
      $relation_bundles[] = $bundle_id; 
    }
  }
  if(!empty($relation_bundles)){
    $info_service = \Drupal::service('relationship_nodes.relationship_info_service');
    foreach($relation_bundles as $relation_bundle_id){
      $bundles['node'][$relation_bundle_id]['relation_bundle'] = $info_service->getRelationBundleInfo($relation_bundle_id);
    }
  }
}


function relationship_nodes_entity_type_build(array &$entity_types) {
  if (isset($entity_types['node'])) {
    $entity_types['node']->setHandlerClass('inline_form', RelationExtendedEntityInlineForm::class);
  }
}


function relationship_nodes_form_alter(array &$form, FormStateInterface $form_state, $form_id) {
  $alter_form_service = null;
  switch($form_id){
    case 'node_type_edit_form':
      $alter_form_service = \Drupal::service('relationship_nodes.node_type_form_alter');
      break;
    case 'taxonomy_vocabulary_form': 
      $alter_form_service = \Drupal::service('relationship_nodes.vocab_form_alter');
      break;
    default:
      if ($form_state->getFormObject() instanceof EntityFormInterface) {
        $alter_form_service = \Drupal::service('relationship_nodes.parent_node_form_alter');    
      }
      break;
  }

  if ($alter_form_service) {
    $alter_form_service->alterForm($form, $form_state, $form_id);
  }
}



function relationship_nodes_local_tasks_alter(&$local_tasks) {
  $field_config_helper = \Drupal::service('relationship_nodes.relation_field_config_helper');
  $field_config_helper->overrideLocalTasksEdit($local_tasks);

}



function relationship_nodes_module_implements_alyter(array &$implementations, $hook) {
  if ($hook === 'entity_type_alter') {
    $module = 'relationship_nodes';
    if (isset($implementations[$module])) {
      $weight = $implementations[$module];
      unset($implementations[$module]);
      $implementations[$module] = $weight;
    }
  }
}


function relationship_nodes_uninstall($is_syncing) : void {
   $rn_updated_classes = [
    'field_storage_config' => FieldStorageConfig::class, 
    'field_config' => FieldConfig::class, 
    'node_type' => NodeType::class, 
    'taxonomy_vocabulary' => Vocabulary::class];

  foreach ($rn_updated_classes as $storage_id => $class) {
    $storage =  \Drupal::entityTypeManager()->getStorage($storage_id);

    if(!$storage){
      continue;
    }
    foreach ($storage->loadMultiple() as &$object) {

      if (!$object instanceof ConfigEntityInterface) {
        continue;
      }

      $rn_settings = $object->getThirdPartySettings('relationship_nodes');

      if (empty($rn_settings)) {
        continue;
      }

      if (method_exists($object, 'setLocked')) {
        $object->setLocked(FALSE);
      }

      foreach ($rn_settings as $rn_setting => $value) {
        $object->unsetThirdPartySetting('relationship_nodes', $rn_setting);
      }

      $object->save();
    }
  }
}